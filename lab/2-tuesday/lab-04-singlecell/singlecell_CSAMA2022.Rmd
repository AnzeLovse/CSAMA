---
title: "Single-cell RNA-seq workflow"
subtitle: "CSAMA 2022 Version"
author:
    - name: Davide Risso
      affiliation: 
        - Department of Statistical Sciences, University of Padova, Padova, Italy
date: "21 June 2022"
bibliography: biblio.bib
output: BiocStyle::html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = FALSE, error = FALSE, message = FALSE,
                      warning = FALSE, echo = TRUE, results = "markup",
                      fig.align = "center", collapse = TRUE)
```

# Introduction

In this tutorial we walk through a typical single-cell RNA-seq analysis using Bioconductor packages.
We will try to cover data from different protocols, but some of the EDA/QC steps will be focused on the 10X Genomics Chromium protocol.

We start from the output of the Cell Ranger preprocessing software. This is an open source software suite that allows to pre-process the FASTQ files generated by the sequencing platform and perform alignment and quantification. 

We will perform exploratory data analysis (EDA) and quality control (QC), focusing on single-cell, and sometimes droplet-specific, issues, such as the detection of empty droplet and of doublets.
We will then cover dimensionality reduction, cell type identification, pseudotime inference, and (briefly) multi-sample differential expression.

Most of the steps covered here (and much more!) are described in great details in the [Orchestrating Single Cell Analysis (OSCA)](https://bioconductor.org/books/release/OSCA/) book [@amezquita2020orchestrating]. I encourage everyone to use that as a reference for the most typical single-cell analyses with Bioconductor.

[Bioconductor](https://bioconductor.org/) [@Huber2015Orchestrating] has many packages supporting the analysis of single-cell RNA-seq data and their package vignettes constitute an excellent resource.

While not covered in this tutorial, there are packages and software tools for the analysis of single-cell data outside of Bioconductor too. Popular tools include the [Seurat R package](https://satijalab.org/seurat/) and the [scanpy python package](https://scanpy.readthedocs.io/en/stable/). The Bioconductor single-cell echosystem tries whenever possible to provide data structures and coercion functions that make it easy to interoperate between Bioconductor and external software.

## Experimental data

We will use several experimental datasets throughout this tutorial. In particular, we will use:

- Peripheral Blood Mononuclear Cell (PBMC) data from healthy donors provided by 10X Genomics as example datasets, available through the [TENxPBMCData Bioconductor package](https://bioconductor.org/packages/TENxPBMCData/).
- A Fluidigm C1 dataset that studies the differentiation of stem cells in the mouse olfactory epithelium [@fletcher2017deconstructing], available through the [scRNAseq Bioconductor package](https://bioconductor.org/packages/scRNAseq/).
- A 10X Genomics dataset that studies the effect of a treatment on mouse cortex [@crowell2020muscat], available through the [muscData Bioconductor package](https://bioconductor.org/packages/muscData/)

In particular, the [scRNAseq Bioconductor package](https://bioconductor.org/packages/scRNAseq/) contains a wide variety of experimental single-cell datasets that can be used for illustration, exploration, and methods development.

## The SingleCellExperiment class

One common feature of the datasets that we will use is that they are all stored as objects of the `SingleCellExperiment` class.

`SingleCellExperiment` is a S4 class that _extends_ `SummarizedExperiment` and can be used for efficiently storing and working with single-cell data in R/Bioconductor.

This class serves as the common infrastructure for across 70+ single-cell-related Bioconductor packages and allows users to mix and match packages by different developers. This class implements a data structure that stores all aspects of our single-cell data - gene-by-cell expression data, per-cell metadata and per-gene annotation - and manipulate them in a synchronized manner.

```{r, results="asis", out.width="100%", echo=FALSE}
knitr::include_graphics("img/SingleCellExperiment.png")
```

A more thorough overview of `SingleCellExperiment` can be found in [Chapter 4 of OSCA](http://bioconductor.org/books/3.15/OSCA.intro/the-singlecellexperiment-class.html).

# Exploratory Data Analysis / Quality Control

In this section we focus on EDA/QC steps that are typical in a single-cell analysis.

We start by considering a dataset on Peripheral Blood Mononuclear Cell (PBMC) data from a healthy donor provided by 10X Genomics. We use the [DropletTestFiles Bioconductor package](https://bioconductor.org/packages/DropletTestFiles/) to download the raw (i.e., unfiltered) count matrix that contains the UMI counts of all genes in all droplets.

```{r}
library(DropletTestFiles)
raw.path <- getTestFile("tenx-2.1.0-pbmc4k/1.0.0/raw.tar.gz")
out.path <- file.path(tempdir(), "pbmc4k")
untar(raw.path, exdir=out.path)

library(DropletUtils)
fname <- file.path(out.path, "raw_gene_bc_matrices/GRCh38")
sce.pbmc <- read10xCounts(fname, col.names=TRUE)
sce.pbmc
```
The `read10xCounts` function starts from the output of the Cell Ranger software and imports the data into R as an object of class `SingleCellExperiment`.

We can notice that the dimension of the matrix is very big; in fact this matrix includes the UMI that have been detected in all the droplets that have been sequenced, including the empty droplets that may contain only ambient RNA.

This is a very sparse matrix, with a large fraction of zeros; `read10xCounts` is aware of this and stores the counts as a sparse matrix, which has a very small memory footprint.

```{r}
class(counts(sce.pbmc))
```

**Exercise**: Explore the `SingleCellExperiment` object and its slots. In particular, the `assay`, `counts`, `colData`, `rowData` assessors.

Before starting the analysis, it may be a good idea to store the names of the genes in a more human-friendly ID system. We can also include information on the chromosome location of the genes; this will be useful for e.g. identifying mitochondrial genes.

```{r}
library(scuttle)
rownames(sce.pbmc) <- uniquifyFeatureNames(
    rowData(sce.pbmc)$ID, rowData(sce.pbmc)$Symbol)

library(EnsDb.Hsapiens.v86)
rowData(sce.pbmc)$location <- mapIds(EnsDb.Hsapiens.v86,
                                     keys=rowData(sce.pbmc)$ID, 
                                     column="SEQNAME", keytype="GENEID")
rowData(sce.pbmc)
```
**Exercise**: compute the proportion of zero for each droplet (column) and draw the distribution across the dataset.

## Empty droplets

The first step is the identification of droplets that do not contain any live cell.

The reason why these droplets contain some RNA is that there may be some ambient RNA due to some cell leaking or they may contain dead or dying cells.

The `barcodeRanks` function can be used to rank the barcodes by number of UMIs and to estimate the knee and inflection point of the distribution.

```{r}
bcrank <- barcodeRanks(counts(sce.pbmc))

# Only showing unique points for plotting speed.
uniq <- !duplicated(bcrank$rank)
plot(bcrank$rank[uniq], bcrank$total[uniq], log="xy",
    xlab="Rank", ylab="Total UMI count", cex.lab=1.2)

abline(h=metadata(bcrank)$inflection, col="darkgreen", lty=2)
abline(h=metadata(bcrank)$knee, col="dodgerblue", lty=2)

legend("bottomleft", legend=c("Inflection", "Knee"), 
        col=c("darkgreen", "dodgerblue"), lty=2, cex=1.2)
```

There is a sharp distinction between droplets with very high counts, very likely to contain a live cell, and droplets with very low counts, very likely to be empty. 

However, it is not straightforward to classify the droplets in the middle of the distribution.

We can apply a statistical test of hypothesis to decide, for each droplet, if its RNA profile is significantly different from the profile of ambient RNA, estimated from the very low counts [@lun2019emptydrops].

We use a very low threshold on the False Discovery Rate to have very few false positive cells.

```{r}
set.seed(100)
e.out <- emptyDrops(counts(sce.pbmc))
summary(e.out$FDR <= 0.001)
```

The large majority of droplets are not tested, since by default all droplets with fewer than 100 UMIs are considered empty.

```{r}
table(colSums(counts(sce.pbmc))>100, e.out$FDR<=0.001, useNA = "ifany")
```

We can now proceed by removing the empty droplets and keep only the ones identified to be cells.

```{r}
sce.pbmc <- sce.pbmc[,which(e.out$FDR <= 0.001)]
sce.pbmc
```

## Quality control

The fact that the droplets are not empty does not automatically mean that they should be kept in the analysis. They may contain damaged or dying cells.

Our aim here is to identify and potentially remove those cells that have lower quality. There are several methods to identify such cells; here we use the simple but effective strategy of removing cells with high percentages of mitochondrial reads.

This is justified by the fact that mitochondiral genes are involved in biological processes in response to stress and apoptosis. Hence, high mitochondrial gene expression may be an indication of damaged or stressed cells.

The `perCellQCMetrics` function can be used to compute a set of metrics useful to evaluate the quality of the samples. The `isOutlier` function uses a data driven threshold to define cells of lower quality compared to the rest of the dataset.

```{r}
stats <- perCellQCMetrics(sce.pbmc,
            subsets=list(Mito=which(rowData(sce.pbmc)$location=="MT")))
high.mito <- isOutlier(stats$subsets_Mito_percent, type="higher")
table(high.mito)
```

Finally, it is convenient to include this information in the `colData` of the object, e.g. to use it in plotting functions.

```{r}
colData(sce.pbmc) <- cbind(colData(sce.pbmc), stats)
sce.pbmc$discard <- high.mito

library(scater)
plotColData(sce.pbmc, y="subsets_Mito_percent",
        colour_by="discard")
plotColData(sce.pbmc, y="detected",
        colour_by="discard")
plotColData(sce.pbmc, x="sum", y="subsets_Mito_percent",
    colour_by="discard") + scale_x_log10()
```

We can remove the low quality cells from the dataset.

```{r}
sce.pbmc <- sce.pbmc[,!high.mito]
sce.pbmc
```
## Normalization

Here, we use the scran method to normalize the data for differences in sequencing depth. This approach is based on the deconvolution of size factors estimated from pools of cells [@l2016pooling].

Since we have a heterogeneous cell population, we perform a quick clustering to make sure that we pool together cells that are not too different from each other.

```{r}
library(scran)
cl <- quickCluster(sce.pbmc)
table(cl)
sce.pbmc <- computeSumFactors(sce.pbmc, clusters = cl)
summary(sizeFactors(sce.pbmc))
```

The function returns a `SingleCellExperiment` object with the estimated size factors stored in the `colData`. To actually normalize the data, we can use the `logNormCounts` function that will use the size factors stored in the object to normalize the data and save the log-normalized counts as a second assay in the object.

```{r}
sce.pbmc <- logNormCounts(sce.pbmc)
sce.pbmc
```

**Exercise**: Explore the `logcounts` assessor and the `assayNames`, `assays` and `assay` methods to extract the original counts and the log-normalized counts from the object. 

We can check that the estimated library sizes are not too far from the _library size factors_, estimated from the total number of counts.

```{r}
plot(librarySizeFactors(sce.pbmc), sizeFactors(sce.pbmc), xlab="Library size factor",
    ylab="Deconvolution size factor", log='xy', pch=16,
    col=as.integer(factor(cl)))
abline(a=0, b=1, col="red")
```

## Highly variable genes (HVGs)

```{r}
library(scran)
set.seed(1001)
dec.pbmc <- modelGeneVarByPoisson(sce.pbmc)
head(dec.pbmc)
```

Per ogni gene, la funzione `modelGeneVarByPoisson`, calcola la media e la varianza dei dati, adatta un modello di Poisson che rappresenta la variabilità tecnica, mentre la variabilità residua è considerata biologica. Infine, si utilizza un test per l'ipotesi nulla che la componente di variabilità biologica sia nulla.

Possiamo selezionare i geni per cui questo test è significativo o in alternativa possiamo selezionare un numero prefissato di geni (per es. 1000 o il 10%) la cui varianza biologica è massima. Scegliamo quest'ultima strategia.

```{r}
top.pbmc <- getTopHVGs(dec.pbmc, prop=0.1)
head(top.pbmc)

plot(dec.pbmc$mean, dec.pbmc$total, pch=16, cex=0.5,
    xlab="Mean of log-expression", ylab="Variance of log-expression")
curfit <- metadata(dec.pbmc)
curve(curfit$trend(x), col='dodgerblue', add=TRUE, lwd=2)
```

## PCA

Possiamo utilizzare i geni più variabili per calcolare le componenti principali da utilizzare per la visualizzazione dei dati.

Come sempre, il numero di componenti da mantenere nell'analisi è difficile da stimare. In questo contesto, possiamo usare i geni ad alta variabilità tecnica e bassa variabilità biologica per stimare le componenti che catturano solo rumore e niente biologia.

L'assunzione principale è che la variabilità biologica sia maggiore di quella tecnica, ovvero che le prime componenti principali rappresentano la variabilità biologica. Questa strategia è implementata in `denoisePCA`.

```{r}
set.seed(10000)
sce.pbmc <- denoisePCA(sce.pbmc, subset.row=top.pbmc, technical=dec.pbmc)
sce.pbmc
ncol(reducedDim(sce.pbmc, "PCA"))
```

Proviamo a visualizzare i dati nello spazio delle prime due componenti principali.

```{r}
plotPCA(sce.pbmc)
```

Nei dati a singola cellula, le prime due componenti principali spesso mettono in luce le  differenze tra i maggiori tipi cellulari presenti, ma spesso non sono in grado di distinguere tra tipi cellulari simili tra loro.

Per questo sono spesso utilizzate tecniche non lineari, come il t-SNE, che vedremo a lezione.

```{r}
set.seed(100000)
sce.pbmc <- runTSNE(sce.pbmc, dimred="PCA")
sce.pbmc
```


```{r}
plotTSNE(sce.pbmc)
```


# Identificazione dei doublet

Come detto, potrebbe succedere che in una droplet vengano catturate due cellule anziché una.
Ci sono dei metodi statistici per identificare queste cellule doppie, in gergo "doublet".

Vediamo solo una strategia, basata sulla simulazione di doublet a partire da due cellule diverse.

```{r}
library(scDblFinder)
dbl.dens <- computeDoubletDensity(sce.pbmc, subset.row=top.pbmc, 
    d=ncol(reducedDim(sce.pbmc)))
summary(dbl.dens)
sce.pbmc$DoubletScore <- dbl.dens
plotTSNE(sce.pbmc, colour_by="DoubletScore")
```
La strategia può essere descritta in questi step:

1. Si simulato migliaia di doublets summando due cellule prese a caso
2. Si calcola la densità di doublet simulate in un intorno di ogni cellula
3. Si calcola la densità di cellule originali in un intorno di ogni cellula
4. Si calcola il rapporto tra le due densità per ottenere uno score

Possiamo definire una soglia per identificare i doublet.

```{r}
dbl.calls <- doubletThresholding(data.frame(score=dbl.dens),
    method="griffiths", returnType="call")
summary(dbl.calls)
```

Eliminiamo i doublets per procedere con l'analisi.

```{r}
sce.pbmc <- sce.pbmc[, dbl.calls == "singlet"]
sce.pbmc
```

# Dimensionality reduction

In questo hands-on ci concentriamo sulla normalizzazione e sulla riduzione della dimensionalità.

Utilizziamo un dataset che studia l'espressione genica di un gruppo di cellule mononucleari del sangue periferico (peripheral blood mononuclear cell, PBMC), sequenziate con la tecnologia a droplet 10X Genomics.

Utilizziamo dei dati già filtrati, in cui sono state eliminate le droplet vuote.

```{r}
library(TENxPBMCData)
donor1 <- TENxPBMCData("frozen_pbmc_donor_a")
donor2 <- TENxPBMCData("frozen_pbmc_donor_b")
set.seed(123123)
idx1 <- sample(seq_len(NCOL(donor1)), 1000)
idx2 <- sample(seq_len(NCOL(donor2)), 1000)
sce.pbmc <- cbind(donor1[,idx1], donor2[,idx2])
counts(sce.pbmc) <- as.matrix(counts(sce.pbmc))
sce.pbmc
colData(sce.pbmc)
```

Prima di procedere con l'analisi rendiamo più leggibili i nomi dei geni e aggiungiamo informazione sul cromosoma in cui si trovano.

```{r}
library(scater)
library(EnsDb.Hsapiens.v86)
rowData(sce.pbmc)$location <- mapIds(EnsDb.Hsapiens.v86, 
                                     keys=rowData(sce.pbmc)$ENSEMBL_ID, 
                                     column="SEQNAME", keytype="GENEID")
```

# Controllo della qualità

Eliminiamo le cellule con percentuale troppo alta di RNA mitocondriale.

```{r}
stats <- perCellQCMetrics(sce.pbmc, 
                          subsets=list(Mito=which(rowData(sce.pbmc)$location=="MT")))
high.mito <- isOutlier(stats$subsets_Mito_percent, type="higher")
table(high.mito)
colData(sce.pbmc) <- cbind(colData(sce.pbmc), stats)
sce.pbmc$discard <- high.mito
plotColData(sce.pbmc, y="subsets_Mito_percent", x = "Individual",
        colour_by="discard")
plotColData(sce.pbmc, y="detected", x = "Individual",
        colour_by="discard")
plotColData(sce.pbmc, x="sum", y="subsets_Mito_percent",
    colour_by="discard") + scale_x_log10()
```

```{r}
sce.pbmc <- sce.pbmc[,!high.mito]
filter <- which(rowSums(counts(sce.pbmc))>0)
sce.pbmc <- sce.pbmc[filter,]
sce.pbmc
```

# Normalizzazione

Utilizziamo il metodo scran per normalizzare i dati.

```{r}
library(scran)
cl <- quickCluster(sce.pbmc)
table(cl)
sce.pbmc <- computeSumFactors(sce.pbmc, clusters = cl)
summary(sizeFactors(sce.pbmc))

sce.pbmc <- logNormCounts(sce.pbmc)
sce.pbmc

plot(librarySizeFactors(sce.pbmc), sizeFactors(sce.pbmc), xlab="Library size factor",
    ylab="Deconvolution size factor", log='xy', pch=16,
    col=as.integer(factor(cl)))
abline(a=0, b=1, col="red")
```

In alternativa possiamo usare il metodo PsiNorm, implementato nel pacchetto `scone`.

```{r}
library(scone)
sce.pbmc <- PsiNorm(sce.pbmc)
sce.pbmc <- logNormCounts(sce.pbmc, name="psinorm")
sce.pbmc
```

# Riduzione della dimensionalità

## Identificazione di geni più variabili

```{r}
set.seed(1001)
dec.pbmc <- modelGeneVarByPoisson(sce.pbmc)
head(dec.pbmc)
```

Per ogni gene, la funzione `modelGeneVarByPoisson`, calcola la media e la varianza dei dati, adatta un modello di Poisson che rappresenta la variabilità tecnica, mentre la variabilità residua è considerata biologica. Infine, si utilizza un test per l'ipotesi nulla che la componente di variabilità biologica sia nulla.

Possiamo selezionare i geni per cui questo test è significativo o in alternativa possiamo selezionare un numero prefissato di geni (per es. 1000 o il 10%) la cui varianza biologica è massima. Scegliamo quest'ultima strategia.

```{r}
top.pbmc <- getTopHVGs(dec.pbmc, prop=0.1)
head(top.pbmc)
```

## PCA

Possiamo utilizzare i geni più variabili per calcolare le componenti principali da utilizzare per la visualizzazione dei dati.

Come sempre, il numero di componenti da mantenere nell'analisi è difficile da stimare. In questo contesto, possiamo usare i geni ad alta variabilità tecnica e bassa variabilità biologica per stimare le componenti che catturano solo rumore e niente biologia.

L'assunzione principale è che la variabilità biologica sia maggiore di quella tecnica, ovvero che le prime componenti principali rappresentano la variabilità biologica. Questa strategia è implementata in `denoisePCA`.

```{r}
set.seed(10000)
sce.pbmc <- denoisePCA(sce.pbmc, subset.row=top.pbmc, technical=dec.pbmc)
sce.pbmc
ncol(reducedDim(sce.pbmc, "PCA"))
```

Proviamo a visualizzare i dati nello spazio delle prime due componenti principali.

```{r}
plotPCA(sce.pbmc, colour_by = "Individual")
```

## GLM-PCA

La GLM-PCA è implementata nel pacchetto `scry`. Di default usa una Poisson.

```{r}
library(scry)
set.seed(100000)
filtered <- sce.pbmc[top.pbmc,]
filtered <- GLMPCA(filtered, L=10)
filtered
```


```{r}
plotReducedDim(filtered, "GLMPCA", colour_by = "Individual")
```

E' evidente che sia la PCA che la GLMPCA soffrono di un effetto di individuo. Possiamo includere un indicatore per questo effetto.

```{r}
set.seed(3214)
X <- matrix(as.numeric(as.factor(filtered$Individual)))
filtered <- GLMPCA(filtered, L=10, X = X)
```

```{r}
plotReducedDim(filtered, "GLMPCA", colour_by = "Individual")
```

## ZINB-WaVE 

Il modello ZINB-WaVE sfrutta la binomiale negativa con inflazione di zeri. Visto che questi dati contengono UMI non ci aspettiamo una grande differenza con GLMPCA.

```{r}
library(NewWave)
set.seed(222)
filtered <- newWave(filtered, X = "~Individual")
filtered
plotReducedDim(filtered, "newWave", colour_by = "Individual")
```

Per la visualizzazione è ancora possibile usare il t-SNE, ma utilizzando come spazio ad alta dimensionalità le 10 componenti identificate da GLMPCA o NewWave.

```{r}
set.seed(2242)
filtered <- runTSNE(filtered, dimred="newWave")
plotTSNE(filtered, colour_by = "Individual")
```

## PCA

## Integration

MNN

## Count-based models

GLM-PCA and NewWave

# Cell type assignment

## Clustering

Come detto nelle video lezioni, ci sono sostanzialmente due possibili strategie per l'identificazione dei tipi cellulari:

1. Clustering
2. Classificazione con reference

Tipicamente il clustering si effettua in uno spazio a dimensione ridotta, a seguito di PCA o altre tecniche adatte ai dati di conteggio.

Al contrario la classificazione con dati reference si effettua a partire dai dati normalizzati.

Come negli hands-on precedenti, utilizziamo un dataset che studia l'espressione genica di un gruppo di cellule mononucleari del sangue periferico (peripheral blood mononuclear cell, PBMC), sequenziate con la tecnologia a droplet 10X Genomics.

Possiamo quindi quindi utilizzare il codice visto nell'hands-on precedente per effettuare **filtraggio**, **normalizzazione** e **riduzione della dimensionalità**.

```{r}
library(TENxPBMCData)
donor1 <- TENxPBMCData("frozen_pbmc_donor_a")
donor2 <- TENxPBMCData("frozen_pbmc_donor_b")
set.seed(123123)
idx1 <- sample(seq_len(NCOL(donor1)), 1000)
idx2 <- sample(seq_len(NCOL(donor2)), 1000)
sce.pbmc <- cbind(donor1[,idx1], donor2[,idx2])
counts(sce.pbmc) <- as.matrix(counts(sce.pbmc))
sce.pbmc
```

```{r}
library(scater)
library(EnsDb.Hsapiens.v86)
rowData(sce.pbmc)$location <- mapIds(EnsDb.Hsapiens.v86, 
                                     keys=rowData(sce.pbmc)$ENSEMBL_ID, 
                                     column="SEQNAME", keytype="GENEID")
```

```{r}
stats <- perCellQCMetrics(sce.pbmc, 
                          subsets=list(Mito=which(rowData(sce.pbmc)$location=="MT")))
high.mito <- isOutlier(stats$subsets_Mito_percent, type="higher")
colData(sce.pbmc) <- cbind(colData(sce.pbmc), stats)
sce.pbmc$discard <- high.mito
```

```{r}
sce.pbmc <- sce.pbmc[,!high.mito]
filter <- which(rowSums(counts(sce.pbmc))>0)
sce.pbmc <- sce.pbmc[filter,]
```

```{r}
library(scran)
cl <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, clusters = cl)
sce.pbmc <- logNormCounts(sce.pbmc)
```

```{r}
set.seed(1001)
dec.pbmc <- modelGeneVarByPoisson(sce.pbmc)
top.pbmc <- getTopHVGs(dec.pbmc, prop=0.1)
```

```{r}
library(NewWave)
set.seed(100000)
filtered <- sce.pbmc[top.pbmc,]
filtered <- newWave(filtered, X = "~Individual", K=10, children=4,
                     n_gene_disp = 100, n_gene_par = 100, n_cell_par = 100)
filtered
```

```{r}
set.seed(8872)
filtered <- runTSNE(filtered, dimred="newWave")
plotTSNE(filtered, colour_by = "Individual")
```

# Clustering

Uno dei metodi più utilizzati per il clustering è il metodo di Louvain, che si basa su una rete di cellule vicine.

```{r}
library(igraph)
g <- buildSNNGraph(filtered, k=10, use.dimred = 'newWave')
clust <- igraph::cluster_louvain(g)
filtered$Louvain <- factor(membership(clust))
table(filtered$Louvain)
plotTSNE(filtered, colour_by="Louvain")
```

Possiamo confrontare questo metodo con il metodo walktrap a partire dalla stessa rete.

```{r}
clust <- igraph::cluster_walktrap(g)
filtered$walktrap <- factor(membership(clust))
table(filtered$walktrap, filtered$Louvain)
plotTSNE(filtered, colour_by="walktrap")
```

Possiamo anche utilizzare l'approccio k-means. In questo caso possiamo confrontare il classico k-means, con il mini-batch k-means.

```{r}
set.seed(102)
km <- kmeans(reducedDim(filtered, "newWave"), centers = 10, nstart = 10)
filtered$kmeans10 <- factor(km$cluster)
table(filtered$walktrap, filtered$kmeans10)
plotTSNE(filtered, colour_by="kmeans10")
```

```{r}
library(mbkmeans)
set.seed(1822)
mbkm <- mbkmeans(filtered, reduceMethod = "newWave", clusters = 10, num_init = 20, batch_size=1000)
filtered$mbkmeans10 <- factor(mbkm$Clusters)
table(filtered$mbkmeans10, filtered$kmeans10)
plotTSNE(filtered, colour_by="mbkmeans10")
```

Possiamo confrontare i quattro metodi con l'indice di silhouette e con l'indice di Rand.

```{r}
library(cluster)
library(mclust)
adjustedRandIndex(filtered$walktrap, filtered$Louvain)
adjustedRandIndex(filtered$walktrap, filtered$kmeans10)
adjustedRandIndex(filtered$walktrap, filtered$mbkmeans10)
adjustedRandIndex(filtered$kmeans10, filtered$mbkmeans10)
```

```{r}
d <- dist(reducedDim(filtered, "newWave"))
plot(silhouette(km$cluster, d), main="k-means (k=10)")
plot(silhouette(mbkm$Clusters, d), main="mini-batch k-means (k=10)")
plot(silhouette(as.numeric(filtered$Louvain), d), main="Louvain")
plot(silhouette(as.numeric(filtered$walktrap), d), main="Walktrap")
```

## Identificazione di geni marcatori

Possiamo usare un semplice t-test per confrontare l'espressione media di un gene in un cluster contro quella media in tutti gli altri cluster.

```{r}
rownames(filtered) <- rowData(filtered)$Symbol_TENx
markers <- findMarkers(filtered, filtered$Louvain)
head(markers[[1]])
```

I p-value non sono validi, ma si possono usare per ordinare i geni e per esempio osservare i primi 10 per gruppo.

```{r}
mm <- unique(unlist(lapply(markers, function(x) rownames(x)[1:10])))
plotGroupedHeatmap(filtered, features=mm, group="Louvain", center=TRUE)
```

# Classificazione con reference

In alternativa, si può utilizzare un dataset di riferimento, su cui allenare un classificatore che si adatta poi ai dati in oggetto. In questo modo si possono otttenere, oltre a gruppi di cellule, delle etichette con l'identità biologica dei tipi cellulari.

Come detto il metodo è implementato nel pacchetto `SingleR`. Questo pacchetto può essere utilizzato con qualsiasi dataset annotato come reference, sia bulk sia single-cell.

Il pacchetto `celldex` contiene dataset generali per l'annotazione delle cellule (uomo e topo).

```{r}
library(SingleR)
library(celldex)
ref <- MonacoImmuneData()
ref
colData(ref)
table(ref$label.fine)
```

Possiamo procedere con la classificazione. Prima usiamo la classificazione meno fine per illustrazione.

```{r}
pred <- SingleR(test = filtered, ref = ref, 
    labels = ref$label.main, assay.type.test="logcounts")
head(pred)
plotScoreHeatmap(pred)
```

Il metodo restituisce uno score continuo, ma anche un'etichetta che è la previsione "migliore" secondo il modello.

Ora possiamo procedere con una classificazione più fine.

```{r}
pred_fine <- SingleR(test = filtered, ref = ref, 
    labels = ref$label.fine, assay.type.test="logcounts")
head(pred_fine)
```

Possiamo inserire entrambe le etichette nell'oggetto

```{r}
filtered$singler <- factor(pred$pruned.labels)
filtered$singler_fine <- factor(pred_fine$pruned.labels)
```

```{r}
pal <- c(palette.colors(8, "Accent"), palette.colors(8, "Dark 2"),
         palette.colors(8, "Paired"))

plotTSNE(filtered, colour_by = "singler") + scale_color_manual(values=pal)
plotTSNE(filtered, colour_by = "singler_fine") + scale_color_manual(values=pal)
```


```{r}
library(pheatmap)
pheatmap(log10(table(filtered$singler, filtered$Louvain)+1), scale = "none")
pheatmap(log10(table(filtered$singler, filtered$walktrap)+1), scale = "none")
pheatmap(log10(table(filtered$singler_fine, filtered$Louvain)+1), scale = "none")
```

```{r}
pred <- SingleR(test = filtered, ref = ref, 
    labels = ref$label.main, assay.type.test="logcounts",
    clusters = filtered$walktrap)
pred
plotScoreHeatmap(pred)
```

# Conclusioni

Come illustra questo esempio non è semplice assegnare un'etichetta alle cellule in generale. Esiste un tradeoff tra accuratezza e risoluzione, e spesso si ricorre a metodi semi-supervisionati in cui il clustering o l'annotazione automatica vengono integrate con considerazioni basate su geni marcatori.

## Reference-based annotation

SingleR

# Bonus section: Psuedotime inference

## Differentially expressed genes

# Bonus section: Multi-sample analysis

## Pseudo-bulk analysis


# Session information

It is good practice to always include a list of the software versions that were used to perform a given analysis, for reproducibility and trouble-shooting purposes. One way of achieving this is via the `sessionInfo()` function.

```{r}
sessionInfo()
```

# References

